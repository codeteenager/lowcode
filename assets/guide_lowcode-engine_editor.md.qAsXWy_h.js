import{_ as s,c as a,o as i,V as n}from"./chunks/framework.uGiKYcNl.js";const u=JSON.parse('{"title":"编排","description":"","frontmatter":{},"headers":[],"relativePath":"guide/lowcode-engine/editor.md","filePath":"guide/lowcode-engine/editor.md","lastUpdated":1706692483000}'),e={name:"guide/lowcode-engine/editor.md"},l=n(`<h1 id="编排" tabindex="-1">编排 <a class="header-anchor" href="#编排" aria-label="Permalink to &quot;编排&quot;">​</a></h1><p>所谓编排，即将设计器中的所有物料，进行布局设置、组件设置、交互设置（JS 编写/逻辑编排）后，形成符合业务诉求的 schema 描述。</p><h2 id="编排的本质" tabindex="-1">编排的本质 <a class="header-anchor" href="#编排的本质" aria-label="Permalink to &quot;编排的本质&quot;">​</a></h2><p>首先，思考编排的本质是什么？</p><p>编排的本质是生产符合《低代码引擎搭建协议规范》的数据，在这个场景里，协议是通过 JSON 来承载的。如：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;componentName&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Page&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;props&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;layout&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;wide&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;children&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &quot;componentName&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Button&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &quot;props&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;size&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;large&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>可是在真实场景，节点数可能有成百上千，每个节点都具有新增、删除、修改、移动、插入子节点等操作，同时还有若干约束，JSON 结构操作起来不是很便利，于是我们仿 DOM 设计了 节点模型&amp; 属性模型，用更具可编程性的方式来编排，这是编排系统的基石。</p><p>其次，每次编排动作后（CRUD），都需要实时的渲染出视图。广义的视图应该包括各种平台上的展现，浏览器、Rax、小程序、Flutter 等等，所以使用何种渲染器去渲染 JSON 结构应该可以由用户去扩展，我们定义一种机制去衔接设计态和渲染态。</p><p>至此，我们已经完成了编排模块最基础的功能，接下来，就是完善细节，逐步丰满功能。比如：</p><ol><li>编排面板的整体功能区划分设计；</li><li>节点属性设计；节点删除、移动等操作设计；容器节点设计；</li><li>节点拖拽功能、拖拽定位设计和实现。</li><li>节点在画布上的辅助功能，比如 hover、选中、选中时的操作项、resize、拖拽占位符等</li><li>设计态和渲染态的坐标系转换，滚动监听等；</li><li>快捷键机制；</li><li>历史功能，撤销和重做；</li><li>结构化的插件扩展机制；</li><li>原地编辑功能；</li></ol><p>有非常多模块，但只要记住一点，这些功能的目的都是辅助用户在画布上有更好的编排体验、扩展能力而逐个增加设计的。</p><h2 id="编排功能模块" tabindex="-1">编排功能模块 <a class="header-anchor" href="#编排功能模块" aria-label="Permalink to &quot;编排功能模块&quot;">​</a></h2><h3 id="模型设计" tabindex="-1">模型设计 <a class="header-anchor" href="#模型设计" aria-label="Permalink to &quot;模型设计&quot;">​</a></h3><p>编排实际上操作 schema，但是实际代码运行的过程中，我们将 schema 分成了很多层，每一层有各自的职责，他们所负责的功能是明确清晰的。这就是低代码引擎中的模型设计。</p><p>我们通过将 schema 和常用的操作等结合起来，最终将低代码引擎的模型分为节点模型、属性模型、文档模型和项目模型。</p><h4 id="项目模型-project" tabindex="-1">项目模型（Project） <a class="header-anchor" href="#项目模型-project" aria-label="Permalink to &quot;项目模型（Project）&quot;">​</a></h4><p>项目模型提供项目管理能力。通常一个引擎启动会默认创建一个 Project 实例，有且只有一个。项目模型实例下可以持有多个文档模型的实例，而当前处于设计器设计状态的文档模型，我们将其添加 active 标识，也将其称为 currentDocument，可以通过 project.currentDocument 获得。</p><p>一个 Project 包含若干个 DocumentModel 实例，即项目模型和文档模型的关系是 1 对 n，如下图所示：</p>`,18),t=[l];function p(r,h,o,k,c,d){return i(),a("div",null,t)}const m=s(e,[["render",p]]);export{u as __pageData,m as default};
